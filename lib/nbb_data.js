import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var hFa=new $APP.t("clojure.data","diff","clojure.data/diff",-683865998,null),iFa=new $APP.t(null,"diff","diff",-518492986,null);var jFa=$APP.GO.h($APP.ZI,null),kFa=new $APP.k(null,1,[iFa,function(){var a=new $APP.hd(function(){return $APP.ou},hFa,$APP.Ih([$APP.S,$APP.O,$APP.xl,$APP.Yw,$APP.om,$APP.yl,$APP.XL,$APP.Z,$APP.N,$APP.NC],[$APP.ZI,iFa,"clojure/data.cljs",11,1,144,144,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.gH,$APP.fH],null)),"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.",
$APP.l($APP.ou)?$APP.ou.I:null])),b=$APP.q(a),c=$APP.Xd(a);a=$APP.l(null)?null:$APP.O.g(c);var d=new $APP.k(null,4,[$APP.S,jFa,$APP.O,a,$APP.Z,$APP.Z.g(c),$APP.N,$APP.N.g(c)],null);return $APP.l($APP.Wp.g(c))?$APP.AO.j(a,b,d):$APP.l(function(){var e=$APP.pp.g(c);return $APP.l(e)?e:$APP.Dp.g(c)}())?$APP.BO.j(a,b,d):$APP.lt.j(a,b,d)}()],null);$APP.$t(new $APP.k(null,1,[$APP.Mp,new $APP.k(null,1,[$APP.ZI,kFa],null)],null));