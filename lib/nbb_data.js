import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var vFa=new $APP.r("clojure.data","diff","clojure.data/diff",-683865998,null),wFa=new $APP.r(null,"diff","diff",-518492986,null);var ria=$APP.py($APP.zJ),sia=new $APP.g(null,1,[wFa,function(){var a=new $APP.Dd(function(){return $APP.mz},vFa,$APP.Oj([$APP.O,$APP.N,$APP.Km,$APP.vB,$APP.io,$APP.Lm,$APP.BP,$APP.U,$APP.V,$APP.mH],[$APP.zJ,wFa,"clojure/data.cljs",11,1,144,144,$APP.R(new $APP.H(null,2,5,$APP.I,[$APP.wI,$APP.vI],null)),"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.",
$APP.m($APP.mz)?$APP.mz.A:null])),b=$APP.q(a);a=$APP.Be(a);var c=$APP.m(null)?null:$APP.N.g(a),d=new $APP.g(null,4,[$APP.O,ria,$APP.N,c,$APP.U,$APP.U.g(a),$APP.V,$APP.V.g(a)],null);return $APP.m($APP.Ys.g(a))?$APP.jy(c,b,d):$APP.m($APP.is.g(a))?$APP.ky(c,b,d):$APP.iy(c,b,d)}()],null);$APP.Wy(new $APP.g(null,1,[$APP.Ts,new $APP.g(null,1,[$APP.zJ,sia],null)],null));