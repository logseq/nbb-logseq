import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var XXa=new $APP.q("clojure.data","diff","clojure.data/diff",-683865998,null),YXa=new $APP.q(null,"diff","diff",-518492986,null);var ZXa=$APP.kN.h($APP.FI,null),$Xa=new $APP.h(null,1,[YXa,function(){var a=new $APP.Ed(function(){return $APP.cx},XXa,$APP.gi([$APP.R,$APP.Q,$APP.Sl,$APP.$z,$APP.Pm,$APP.Tl,$APP.CK,$APP.W,$APP.N,$APP.iF],[$APP.FI,YXa,"clojure/data.cljs",11,1,144,144,$APP.K(new $APP.H(null,2,5,$APP.J,[$APP.yH,$APP.xH],null)),"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.",
$APP.k($APP.cx)?$APP.cx.H:null])),b=$APP.n(a),c=$APP.ue(a);a=$APP.k(null)?null:$APP.Q.g(c);var d=new $APP.h(null,4,[$APP.R,ZXa,$APP.Q,a,$APP.W,$APP.W.g(c),$APP.N,$APP.N.g(c)],null);return $APP.k($APP.Uq.g(c))?$APP.eN.j(a,b,d):$APP.k(function(){var e=$APP.oq.g(c);return $APP.k(e)?e:$APP.yq.g(c)}())?$APP.fN.j(a,b,d):$APP.nu.j(a,b,d)}()],null);$APP.$u(new $APP.h(null,1,[$APP.Kq,new $APP.h(null,1,[$APP.FI,$Xa],null)],null));