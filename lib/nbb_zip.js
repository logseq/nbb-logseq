import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var Jfb=new $APP.q(null,"make-node","make-node",-1550461835,null),Kfb=new $APP.q("clojure.zip","append-child","clojure.zip/append-child",-1333956306,null),Lfb=new $APP.q("clojure.zip","insert-child","clojure.zip/insert-child",-210602132,null),Mfb=new $APP.q("clojure.zip","end?","clojure.zip/end?",381053413,null),Nfb=new $APP.q(null,"lefts","lefts",1054400638,null),Ofb=new $APP.q("clojure.zip","node","clojure.zip/node",-1345203614,null),Pfb=new $APP.q("clojure.zip","edit","clojure.zip/edit",-442418038,
null),Qfb=new $APP.q("clojure.zip","zipper","clojure.zip/zipper",-571036006,null),Rfb=new $APP.q("clojure.zip","next","clojure.zip/next",-1526224397,null),Sfb=new $APP.q("clojure.zip","branch?","clojure.zip/branch?",-1006947869,null),Tfb=new $APP.q("clojure.zip","up","clojure.zip/up",1006365229,null),Ufb=new $APP.q("clojure.zip","children","clojure.zip/children",65376544,null),Vfb=new $APP.q("clojure.zip","leftmost","clojure.zip/leftmost",-1791272498,null),Wfb=new $APP.q(null,"xml-zip","xml-zip",
-1566989793,null),Xfb=new $APP.q("clojure.zip","replace","clojure.zip/replace",413367034,null),Yfb=new $APP.q("clojure.zip","path","clojure.zip/path",1758958974,null),Zfb=new $APP.q("clojure.zip","rightmost","clojure.zip/rightmost",1799140158,null),$fb=new $APP.q("clojure.zip","xml-zip","clojure.zip/xml-zip",-925187274,null),agb=new $APP.q("clojure.zip","down","clojure.zip/down",1356031458,null),bgb=new $APP.q("clojure.zip","seq-zip","clojure.zip/seq-zip",-395973642,null),cgb=new $APP.q("clojure.zip",
"prev","clojure.zip/prev",-389017676,null),dgb=new $APP.q("clojure.zip","insert-right","clojure.zip/insert-right",194316302,null),egb=new $APP.q("clojure.zip","vector-zip","clojure.zip/vector-zip",986730862,null),fgb=new $APP.q(null,"zipper","zipper",-1153741331,null),ggb=new $APP.q("clojure.zip","left","clojure.zip/left",1740332703,null),hgb=new $APP.q("clojure.zip","root","clojure.zip/root",-1119588559,null),igb=new $APP.q(null,"vector-zip","vector-zip",1075131029,null),jgb=new $APP.q("clojure.zip",
"remove","clojure.zip/remove",859584278,null),kgb=new $APP.q("clojure.zip","insert-left","clojure.zip/insert-left",1476893044,null),lgb=new $APP.q("clojure.zip","rights","clojure.zip/rights",1361118051,null),mgb=new $APP.q("clojure.zip","make-node","clojure.zip/make-node",-640223892,null),ngb=new $APP.q(null,"seq-zip","seq-zip",-2034709283,null),ogb=new $APP.q(null,"rights","rights",2003591322,null),pgb=new $APP.q("clojure.zip","right","clojure.zip/right",-1593586409,null),qgb=new $APP.q("clojure.zip",
"lefts","clojure.zip/lefts",538689815,null);var rgb=$APP.kN.h($APP.ECa,null),sgb=$APP.lu($APP.hi([$APP.se(fgb,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,4,5,$APP.H,[$APP.VG,$APP.$F,Jfb,$APP.HI],null))),$APP.M,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],
null)),$APP.se($APP.eoa,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)),$APP.se($APP.JEa,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)),$APP.se($APP.pla,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,
2,5,$APP.H,[$APP.pK,$APP.VC],null))),$APP.M,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)),$APP.se($APP.tma,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.VC],null))),$APP.M,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)),$APP.se($APP.Nta,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns true if loc represents the end of a depth-first walk"],
null)),$APP.se($APP.sE,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns the node at loc"],null)),$APP.se($APP.fK,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.sE],null))),$APP.M,"Replaces the node at this loc, without moving"],null)),$APP.se($APP.Xoa,new $APP.h(null,3,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,4,5,$APP.H,[$APP.pK,$APP.GH,$APP.jk,$APP.OD],null))),$APP.M,"Replaces the node at this loc with the value of (f node args)",
$APP.rI,new $APP.h(null,6,[$APP.DA,!0,$APP.Rs,2,$APP.DJ,2,$APP.lJ,new $APP.G(null,1,5,$APP.H,[$APP.J($APP.pK,$APP.GH,$APP.OD)],null),$APP.U,$APP.J(new $APP.G(null,4,5,$APP.H,[$APP.pK,$APP.GH,$APP.jk,$APP.OD],null)),$APP.fF,$APP.J(null)],null)],null)),$APP.se(ngb,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.HI],null))),$APP.M,"Returns a zipper for nested sequences, given a root sequence"],null)),$APP.se($APP.yI,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,
1,5,$APP.H,[$APP.pK],null))),$APP.M,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)),$APP.se(Wfb,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.HI],null))),$APP.M,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)),$APP.se(igb,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,
[$APP.HI],null))),$APP.M,"Returns a zipper for nested vectors, given a root vector"],null)),$APP.se(Jfb,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,3,5,$APP.H,[$APP.pK,$APP.sE,$APP.$F],null))),$APP.M,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)),$APP.se($APP.VG,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns true if the node at loc is a branch"],
null)),$APP.se($APP.Nma,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns the loc of the right sibling of the node at this loc, or nil"],null)),$APP.se($APP.oDa,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns a seq of nodes leading to this loc"],null)),$APP.se($APP.HI,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"zips all the way up and returns the root node, reflecting any\n changes."],
null)),$APP.se(ogb,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns a seq of the right siblings of this loc"],null)),$APP.se($APP.$F,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns a seq of the children of node at loc, which must be a branch"],null)),$APP.se($APP.zra,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns the loc of the leftmost sibling of the node at this loc, or self"],
null)),$APP.se($APP.IDa,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)),$APP.se($APP.wAa,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns the loc of the left sibling of the node at this loc, or nil"],null)),$APP.se(Nfb,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,
[$APP.pK],null))),$APP.M,"Returns a seq of the left siblings of this loc"],null)),$APP.se($APP.Bya,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.VC],null))),$APP.M,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)),$APP.se($APP.rxa,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.VC],null))),$APP.M,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],
null)),$APP.se($APP.Zza,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)),$APP.se($APP.CA,new $APP.h(null,2,[$APP.U,$APP.J($APP.Bk,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null))),$APP.M,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null))],[new $APP.h(null,3,[$APP.N,Qfb,$APP.ku,$APP.hx,$APP.mb,new $APP.h(null,
2,[$APP.U,$APP.J(new $APP.G(null,4,5,$APP.H,[$APP.VG,$APP.$F,Jfb,$APP.HI],null)),$APP.M,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],null)],null),new $APP.h(null,
3,[$APP.N,Tfb,$APP.ku,$APP.sx,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)],null),new $APP.h(null,3,[$APP.N,cgb,$APP.ku,$APP.kka,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)],null),new $APP.h(null,3,[$APP.N,dgb,$APP.ku,
$APP.gka,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.VC],null)),$APP.M,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)],null),new $APP.h(null,3,[$APP.N,kgb,$APP.ku,$APP.fka,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.VC],null)),$APP.M,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)],null),new $APP.h(null,3,[$APP.N,Mfb,$APP.ku,$APP.lka,$APP.mb,
new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns true if loc represents the end of a depth-first walk"],null)],null),new $APP.h(null,3,[$APP.N,Ofb,$APP.ku,$APP.ix,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns the node at loc"],null)],null),new $APP.h(null,3,[$APP.N,Xfb,$APP.ku,$APP.zx,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.sE],null)),$APP.M,"Replaces the node at this loc, without moving"],
null)],null),new $APP.h(null,3,[$APP.N,Pfb,$APP.ku,$APP.HN,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,4,5,$APP.H,[$APP.pK,$APP.GH,$APP.jk,$APP.OD],null)),$APP.M,"Replaces the node at this loc with the value of (f node args)"],null)],null),new $APP.h(null,3,[$APP.N,bgb,$APP.ku,function(a){return $APP.hx($APP.Ke,$APP.ff,function(b,c){return $APP.se(c,$APP.te(b))},a)},$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.HI],null)),$APP.M,"Returns a zipper for nested sequences, given a root sequence"],
null)],null),new $APP.h(null,3,[$APP.N,Rfb,$APP.ku,$APP.jka,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)],null),new $APP.h(null,3,[$APP.N,$fb,$APP.ku,function(a){return $APP.hx($APP.sg($APP.Eb),$APP.pq.h($APP.r,$APP.hva),function(b,c){return $APP.vi.j(b,$APP.hva,$APP.k(c)?$APP.qg.h($APP.Jw,
c):c)},a)},$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.HI],null)),$APP.M,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)],null),new $APP.h(null,3,[$APP.N,egb,$APP.ku,function(a){return $APP.hx($APP.Ee,$APP.r,function(b,c){return $APP.se($APP.df(c),$APP.te(b))},a)},$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.HI],null)),$APP.M,"Returns a zipper for nested vectors, given a root vector"],null)],null),new $APP.h(null,
3,[$APP.N,mgb,$APP.ku,$APP.lx,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,3,5,$APP.H,[$APP.pK,$APP.sE,$APP.$F],null)),$APP.M,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)],null),new $APP.h(null,3,[$APP.N,Sfb,$APP.ku,$APP.jx,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns true if the node at loc is a branch"],null)],null),new $APP.h(null,3,[$APP.N,pgb,
$APP.ku,$APP.ux,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns the loc of the right sibling of the node at this loc, or nil"],null)],null),new $APP.h(null,3,[$APP.N,Yfb,$APP.ku,function(a){return $APP.nx.g(a.g?a.g(1):a.call(null,1))},$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns a seq of nodes leading to this loc"],null)],null),new $APP.h(null,3,[$APP.N,hgb,$APP.ku,$APP.dka,$APP.mb,new $APP.h(null,
2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"zips all the way up and returns the root node, reflecting any\n changes."],null)],null),new $APP.h(null,3,[$APP.N,lgb,$APP.ku,function(a){return $APP.px.g(a.g?a.g(1):a.call(null,1))},$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns a seq of the right siblings of this loc"],null)],null),new $APP.h(null,3,[$APP.N,Ufb,$APP.ku,$APP.kx,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,
1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns a seq of the children of node at loc, which must be a branch"],null)],null),new $APP.h(null,3,[$APP.N,Vfb,$APP.ku,$APP.eka,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns the loc of the leftmost sibling of the node at this loc, or self"],null)],null),new $APP.h(null,3,[$APP.N,agb,$APP.ku,$APP.qx,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],
null)],null),new $APP.h(null,3,[$APP.N,ggb,$APP.ku,$APP.yx,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns the loc of the left sibling of the node at this loc, or nil"],null)],null),new $APP.h(null,3,[$APP.N,qgb,$APP.ku,$APP.cka,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns a seq of the left siblings of this loc"],null)],null),new $APP.h(null,3,[$APP.N,Lfb,$APP.ku,$APP.hka,$APP.mb,new $APP.h(null,
2,[$APP.U,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.VC],null)),$APP.M,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)],null),new $APP.h(null,3,[$APP.N,Kfb,$APP.ku,$APP.ika,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,2,5,$APP.H,[$APP.pK,$APP.VC],null)),$APP.M,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)],null),new $APP.h(null,3,[$APP.N,Zfb,$APP.ku,$APP.xx,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,
1,5,$APP.H,[$APP.pK],null)),$APP.M,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)],null),new $APP.h(null,3,[$APP.N,jgb,$APP.ku,$APP.mka,$APP.mb,new $APP.h(null,2,[$APP.U,$APP.J(new $APP.G(null,1,5,$APP.H,[$APP.pK],null)),$APP.M,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null)],null)]),rgb);$APP.Zu(new $APP.h(null,1,[$APP.Lq,new $APP.h(null,1,[$APP.ECa,sgb],null)],null));