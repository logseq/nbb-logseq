import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var L_=function(a,b,c,d){return $APP.se(new $APP.H(null,2,5,$APP.I,[d,null],null),new $APP.k(null,3,[yZa,a,zZa,b,AZa,c],null))},M_=function(a){return a.g?a.g(0):a.call(null,0)},N_=function(a){var b=M_(a);a=yZa.g($APP.te(a));return a.g?a.g(b):a.call(null,b)},O_=function(a){if($APP.l(N_(a))){var b=M_(a);a=zZa.g($APP.te(a));return a.g?a.g(b):a.call(null,b)}throw"called children on a leaf node";},P_=function(a,b,c){a=AZa.g($APP.te(a));return a.h?a.h(b,c):a.call(null,b,c)},T_=function(a){if($APP.l(N_(a))){var b=
$APP.A.j(a,0,null),c=$APP.A.j(a,1,null),d=O_(a),e=$APP.u(d),f=$APP.v(e);e=$APP.w(e);return $APP.l(d)?$APP.se(new $APP.H(null,2,5,$APP.I,[f,new $APP.k(null,4,[Q_,$APP.Sg,R_,$APP.l(c)?$APP.wf.h(R_.g(c),b):new $APP.H(null,1,5,$APP.I,[b],null),BZa,c,S_,e],null)],null),$APP.te(a)):null}return null},V_=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null),d=$APP.Yf(c);c=$APP.C.h(d,Q_);var e=$APP.C.h(d,BZa),f=$APP.C.h(d,R_),h=$APP.C.h(d,S_);d=$APP.C.h(d,U_);return $APP.l(f)?(f=$APP.ue(f),$APP.se($APP.l(d)?
new $APP.H(null,2,5,$APP.I,[P_(a,f,$APP.K.h(c,$APP.zf(b,h))),$APP.l(e)?$APP.vi.j(e,U_,!0):e],null):new $APP.H(null,2,5,$APP.I,[f,e],null),$APP.te(a))):null},CZa=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.Yf(c);var d=$APP.C.h(c,Q_),e=$APP.C.h(c,S_),f=$APP.u(e),h=$APP.v(f);f=$APP.w(f);return $APP.l($APP.l(c)?e:c)?$APP.se(new $APP.H(null,2,5,$APP.I,[h,$APP.vi.l(c,Q_,$APP.wf.h(d,b),$APP.B([S_,f]))],null),$APP.te(a)):null},DZa=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);
c=$APP.Yf(c);var d=$APP.C.h(c,Q_),e=$APP.C.h(c,S_);return $APP.l($APP.l(c)?e:c)?$APP.se(new $APP.H(null,2,5,$APP.I,[$APP.ne(e),$APP.vi.l(c,Q_,$APP.sg.D($APP.wf,d,b,$APP.Gi(e)),$APP.B([S_,null]))],null),$APP.te(a)):a},EZa=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.Yf(c);var d=$APP.C.h(c,Q_),e=$APP.C.h(c,S_);return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.se(new $APP.H(null,2,5,$APP.I,[$APP.ue(d),$APP.vi.l(c,Q_,$APP.ve(d),$APP.B([S_,$APP.zf(b,e)]))],null),$APP.te(a)):null},W_=function(a,
b){$APP.A.j(a,0,null);var c=$APP.A.j(a,1,null);return $APP.se(new $APP.H(null,2,5,$APP.I,[b,$APP.vi.j(c,U_,!0)],null),$APP.te(a))},FZa=new $APP.r(null,"make-node","make-node",-1550461835,null),GZa=new $APP.r("clojure.zip","append-child","clojure.zip/append-child",-1333956306,null),HZa=new $APP.r(null,"insert-right","insert-right",1842751767,null),IZa=new $APP.r("clojure.zip","insert-child","clojure.zip/insert-child",-210602132,null),JZa=new $APP.r("clojure.zip","end?","clojure.zip/end?",381053413,
null),KZa=new $APP.r(null,"insert-left","insert-left",1917369949,null),LZa=new $APP.r(null,"lefts","lefts",1054400638,null),MZa=new $APP.r("clojure.zip","node","clojure.zip/node",-1345203614,null),NZa=new $APP.r("clojure.zip","edit","clojure.zip/edit",-442418038,null),OZa=new $APP.r("clojure.zip","zipper","clojure.zip/zipper",-571036006,null),X_=new $APP.r(null,"item","item",1889905329,null),PZa=new $APP.r("clojure.zip","next","clojure.zip/next",-1526224397,null),zZa=new $APP.G("zip","children","zip/children",
-940194589),QZa=new $APP.r(null,"up","up",1370819414,null),RZa=new $APP.r("clojure.zip","branch?","clojure.zip/branch?",-1006947869,null),SZa=new $APP.r("clojure.zip","up","clojure.zip/up",1006365229,null),TZa=new $APP.r("clojure.zip","children","clojure.zip/children",65376544,null),UZa=new $APP.r("clojure.zip","leftmost","clojure.zip/leftmost",-1791272498,null),VZa=new $APP.r(null,"leftmost","leftmost",-1158121305,null),R_=new $APP.G(null,"pnodes","pnodes",1739080565),WZa=new $APP.r(null,"xml-zip",
"xml-zip",-1566989793,null),XZa=new $APP.r("clojure.zip","replace","clojure.zip/replace",413367034,null),YZa=new $APP.r(null,"end?","end?",217139918,null),ZZa=new $APP.r("clojure.zip","path","clojure.zip/path",1758958974,null),$Za=new $APP.r("clojure.zip","rightmost","clojure.zip/rightmost",1799140158,null),a_a=new $APP.r("clojure.zip","xml-zip","clojure.zip/xml-zip",-925187274,null),b_a=new $APP.r("clojure.zip","down","clojure.zip/down",1356031458,null),c_a=new $APP.G(null,"content","content",15833224),
AZa=new $APP.G("zip","make-node","zip/make-node",1103800591),d_a=new $APP.r("clojure.zip","seq-zip","clojure.zip/seq-zip",-395973642,null),e_a=new $APP.r("clojure.zip","prev","clojure.zip/prev",-389017676,null),f_a=new $APP.r("clojure.zip","insert-right","clojure.zip/insert-right",194316302,null),g_a=new $APP.r("clojure.zip","vector-zip","clojure.zip/vector-zip",986730862,null),U_=new $APP.G(null,"changed?","changed?",-437828330),h_a=new $APP.r(null,"zipper","zipper",-1153741331,null),i_a=new $APP.r("clojure.zip",
"left","clojure.zip/left",1740332703,null),j_a=new $APP.r(null,"append-child","append-child",-1707191801,null),k_a=new $APP.r("clojure.zip","root","clojure.zip/root",-1119588559,null),l_a=new $APP.r(null,"vector-zip","vector-zip",1075131029,null),m_a=new $APP.r(null,"insert-child","insert-child",347166277,null),n_a=new $APP.r("clojure.zip","remove","clojure.zip/remove",859584278,null),o_a=new $APP.r("clojure.zip","insert-left","clojure.zip/insert-left",1476893044,null),p_a=new $APP.r(null,"rightmost",
"rightmost",-1854156251,null),q_a=new $APP.r("clojure.zip","rights","clojure.zip/rights",1361118051,null),r_a=new $APP.r("clojure.zip","make-node","clojure.zip/make-node",-640223892,null),s_a=new $APP.r(null,"seq-zip","seq-zip",-2034709283,null),t_a=new $APP.r(null,"down","down",-1089190199,null),u_a=new $APP.r(null,"rights","rights",2003591322,null),S_=new $APP.G(null,"r","r",-471384190),Q_=new $APP.G(null,"l","l",1395893423),v_a=new $APP.r("clojure.zip","right","clojure.zip/right",-1593586409,null),
BZa=new $APP.G(null,"ppath","ppath",-1758182784),yZa=new $APP.G("zip","branch?","zip/branch?",-998880862),w_a=new $APP.r("clojure.zip","lefts","clojure.zip/lefts",538689815,null);var Y_=function Y_(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return Y_.l(arguments[0],arguments[1],2<c.length?new $APP.Fd(c.slice(2),0,null):null)};Y_.l=function(a,b,c){return W_(a,$APP.sg.j(b,M_(a),c))};Y_.A=2;Y_.F=function(a){var b=$APP.v(a),c=$APP.w(a);a=$APP.v(c);c=$APP.w(c);return this.l(b,a,c)};var x_a=$APP.uS.h($APP.GN,null),y_a=$APP.eu($APP.gi([$APP.se(h_a,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,4,5,$APP.I,[$APP.VI,$APP.mH,FZa,$APP.oM],null))),$APP.M,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],
null)),$APP.se(QZa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)),$APP.se($APP.Gya,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)),$APP.se(HZa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,
2,5,$APP.I,[$APP.iP,X_],null))),$APP.M,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)),$APP.se(KZa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,X_],null))),$APP.M,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)),$APP.se(YZa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns true if loc represents the end of a depth-first walk"],
null)),$APP.se($APP.dE,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns the node at loc"],null)),$APP.se($APP.TO,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,$APP.dE],null))),$APP.M,"Replaces the node at this loc, without moving"],null)),$APP.se($APP.cqa,new $APP.k(null,3,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,4,5,$APP.I,[$APP.iP,$APP.wK,$APP.kk,$APP.gD],null))),$APP.M,"Replaces the node at this loc with the value of (f node args)",
$APP.wL,new $APP.k(null,6,[$APP.cA,!0,$APP.Is,2,$APP.$N,2,$APP.pN,new $APP.H(null,1,5,$APP.I,[$APP.J($APP.iP,$APP.wK,$APP.gD)],null),$APP.Z,$APP.J(new $APP.H(null,4,5,$APP.I,[$APP.iP,$APP.wK,$APP.kk,$APP.gD],null)),$APP.AF,$APP.J(null)],null)],null)),$APP.se(s_a,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.oM],null))),$APP.M,"Returns a zipper for nested sequences, given a root sequence"],null)),$APP.se($APP.KL,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,
1,5,$APP.I,[$APP.iP],null))),$APP.M,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)),$APP.se(WZa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.oM],null))),$APP.M,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)),$APP.se(l_a,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,
[$APP.oM],null))),$APP.M,"Returns a zipper for nested vectors, given a root vector"],null)),$APP.se(FZa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,3,5,$APP.I,[$APP.iP,$APP.dE,$APP.mH],null))),$APP.M,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)),$APP.se($APP.VI,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns true if the node at loc is a branch"],
null)),$APP.se($APP.noa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns the loc of the right sibling of the node at this loc, or nil"],null)),$APP.se($APP.Jxa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns a seq of nodes leading to this loc"],null)),$APP.se($APP.oM,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"zips all the way up and returns the root node, reflecting any\n changes."],
null)),$APP.se(u_a,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns a seq of the right siblings of this loc"],null)),$APP.se($APP.mH,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns a seq of the children of node at loc, which must be a branch"],null)),$APP.se(VZa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns the loc of the leftmost sibling of the node at this loc, or self"],
null)),$APP.se(t_a,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)),$APP.se($APP.Xva,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns the loc of the left sibling of the node at this loc, or nil"],null)),$APP.se(LZa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],
null))),$APP.M,"Returns a seq of the left siblings of this loc"],null)),$APP.se(m_a,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,X_],null))),$APP.M,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)),$APP.se(j_a,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,X_],null))),$APP.M,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)),$APP.se(p_a,new $APP.k(null,
2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)),$APP.se($APP.bA,new $APP.k(null,2,[$APP.Z,$APP.J($APP.zk,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null))),$APP.M,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null))],[new $APP.k(null,3,[$APP.O,OZa,$APP.du,L_,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,4,5,$APP.I,
[$APP.VI,$APP.mH,FZa,$APP.oM],null)),$APP.M,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],null)],null),new $APP.k(null,3,[$APP.O,SZa,$APP.du,V_,$APP.nb,new $APP.k(null,
2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)],null),new $APP.k(null,3,[$APP.O,e_a,$APP.du,function(a){var b=EZa(a);if($APP.l(b))for(a=b;;)if(b=N_(a),b=$APP.l(b)?T_(a):b,$APP.l(b))a=DZa(b);else return a;else return V_(a)},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],
null)],null),new $APP.k(null,3,[$APP.O,f_a,$APP.du,function(a,b){var c=$APP.A.j(a,0,null),d=$APP.A.j(a,1,null);d=$APP.Yf(d);var e=$APP.C.h(d,S_);if(null==d)throw"Insert at top";return $APP.se(new $APP.H(null,2,5,$APP.I,[c,$APP.vi.l(d,S_,$APP.zf(b,e),$APP.B([U_,!0]))],null),$APP.te(a))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,X_],null)),$APP.M,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.O,
o_a,$APP.du,function(a,b){var c=$APP.A.j(a,0,null),d=$APP.A.j(a,1,null);d=$APP.Yf(d);var e=$APP.C.h(d,Q_);if(null==d)throw"Insert at top";return $APP.se(new $APP.H(null,2,5,$APP.I,[c,$APP.vi.l(d,Q_,$APP.wf.h(e,b),$APP.B([U_,!0]))],null),$APP.te(a))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,X_],null)),$APP.M,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)],null),new $APP.k(null,3,[$APP.O,JZa,$APP.du,function(a){return $APP.y.h($APP.IH,
a.g?a.g(1):a.call(null,1))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns true if loc represents the end of a depth-first walk"],null)],null),new $APP.k(null,3,[$APP.O,MZa,$APP.du,M_,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns the node at loc"],null)],null),new $APP.k(null,3,[$APP.O,XZa,$APP.du,W_,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,$APP.dE],null)),
$APP.M,"Replaces the node at this loc, without moving"],null)],null),new $APP.k(null,3,[$APP.O,NZa,$APP.du,Y_,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,4,5,$APP.I,[$APP.iP,$APP.wK,$APP.kk,$APP.gD],null)),$APP.M,"Replaces the node at this loc with the value of (f node args)"],null)],null),new $APP.k(null,3,[$APP.O,d_a,$APP.du,function(a){return L_($APP.Le,$APP.ff,function(b,c){return $APP.se(c,$APP.te(b))},a)},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.oM],
null)),$APP.M,"Returns a zipper for nested sequences, given a root sequence"],null)],null),new $APP.k(null,3,[$APP.O,PZa,$APP.du,function(a){if($APP.y.h($APP.IH,a.g?a.g(1):a.call(null,1)))return a;var b=N_(a);b=$APP.l(b)?T_(a):b;if($APP.l(b))return b;b=CZa(a);if($APP.l(b))return b;for(;;)if($APP.l(V_(a))){b=CZa(V_(a));if($APP.l(b))return b;a=V_(a)}else return new $APP.H(null,2,5,$APP.I,[M_(a),$APP.IH],null)},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,
"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)],null),new $APP.k(null,3,[$APP.O,a_a,$APP.du,function(a){return L_($APP.yg($APP.Gb),$APP.kq.h($APP.u,c_a),function(b,c){return $APP.vi.j(b,c_a,$APP.l(c)?$APP.sg.h($APP.Bw,c):c)},a)},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.oM],null)),$APP.M,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],
null)],null),new $APP.k(null,3,[$APP.O,g_a,$APP.du,function(a){return L_($APP.Fe,$APP.u,function(b,c){return $APP.se($APP.df(c),$APP.te(b))},a)},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.oM],null)),$APP.M,"Returns a zipper for nested vectors, given a root vector"],null)],null),new $APP.k(null,3,[$APP.O,r_a,$APP.du,P_,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,3,5,$APP.I,[$APP.iP,$APP.dE,$APP.mH],null)),$APP.M,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],
null)],null),new $APP.k(null,3,[$APP.O,RZa,$APP.du,N_,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns true if the node at loc is a branch"],null)],null),new $APP.k(null,3,[$APP.O,v_a,$APP.du,CZa,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns the loc of the right sibling of the node at this loc, or nil"],null)],null),new $APP.k(null,3,[$APP.O,ZZa,$APP.du,function(a){return R_.g(a.g?a.g(1):a.call(null,
1))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns a seq of nodes leading to this loc"],null)],null),new $APP.k(null,3,[$APP.O,k_a,$APP.du,function(a){for(;;){if($APP.y.h($APP.IH,a.g?a.g(1):a.call(null,1)))return M_(a);var b=V_(a);if($APP.l(b))a=b;else return M_(a)}},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"zips all the way up and returns the root node, reflecting any\n changes."],null)],null),
new $APP.k(null,3,[$APP.O,q_a,$APP.du,function(a){return S_.g(a.g?a.g(1):a.call(null,1))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns a seq of the right siblings of this loc"],null)],null),new $APP.k(null,3,[$APP.O,TZa,$APP.du,O_,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns a seq of the children of node at loc, which must be a branch"],null)],null),new $APP.k(null,3,[$APP.O,UZa,$APP.du,
function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.Yf(c);var d=$APP.C.h(c,Q_),e=$APP.C.h(c,S_);return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.se(new $APP.H(null,2,5,$APP.I,[$APP.v(d),$APP.vi.l(c,Q_,$APP.Sg,$APP.B([S_,$APP.K.l($APP.Ld(d),new $APP.H(null,1,5,$APP.I,[b],null),$APP.B([e]))]))],null),$APP.te(a)):a},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns the loc of the leftmost sibling of the node at this loc, or self"],null)],null),
new $APP.k(null,3,[$APP.O,b_a,$APP.du,T_,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)],null),new $APP.k(null,3,[$APP.O,i_a,$APP.du,EZa,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns the loc of the left sibling of the node at this loc, or nil"],null)],null),new $APP.k(null,3,[$APP.O,w_a,$APP.du,function(a){return $APP.u(Q_.g(a.g?
a.g(1):a.call(null,1)))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns a seq of the left siblings of this loc"],null)],null),new $APP.k(null,3,[$APP.O,IZa,$APP.du,function(a,b){return W_(a,P_(a,M_(a),$APP.zf(b,O_(a))))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,X_],null)),$APP.M,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.O,GZa,$APP.du,
function(a,b){return W_(a,P_(a,M_(a),$APP.K.h(O_(a),new $APP.H(null,1,5,$APP.I,[b],null))))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[$APP.iP,X_],null)),$APP.M,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.O,$Za,$APP.du,DZa,$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)],
null),new $APP.k(null,3,[$APP.O,n_a,$APP.du,function(a){$APP.A.j(a,0,null);var b=$APP.A.j(a,1,null);b=$APP.Yf(b);var c=$APP.C.h(b,Q_),d=$APP.C.h(b,BZa),e=$APP.C.h(b,R_),f=$APP.C.h(b,S_);if(null==b)throw"Remove at top";if(0<$APP.ce(c))for(a=$APP.se(new $APP.H(null,2,5,$APP.I,[$APP.ue(c),$APP.vi.l(b,Q_,$APP.ve(c),$APP.B([U_,!0]))],null),$APP.te(a));;)if(b=N_(a),b=$APP.l(b)?T_(a):b,$APP.l(b))a=DZa(b);else return a;else return $APP.se(new $APP.H(null,2,5,$APP.I,[P_(a,$APP.ue(e),f),$APP.l(d)?$APP.vi.j(d,
U_,!0):d],null),$APP.te(a))},$APP.nb,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.iP],null)),$APP.M,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null)],null)]),x_a);$APP.Qu(new $APP.k(null,1,[$APP.Cq,new $APP.k(null,1,[$APP.GN,y_a],null)],null));