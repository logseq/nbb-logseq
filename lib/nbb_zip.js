import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var nY=function(a,b,c,d){return $APP.Ud(new $APP.H(null,2,5,$APP.I,[d,null],null),new $APP.k(null,3,[ROa,a,SOa,b,TOa,c],null))},oY=function(a){return a.g?a.g(0):a.call(null,0)},pY=function(a){var b=oY(a);a=ROa.g($APP.Vd(a));return a.g?a.g(b):a.call(null,b)},qY=function(a){if($APP.l(pY(a))){var b=oY(a);a=SOa.g($APP.Vd(a));return a.g?a.g(b):a.call(null,b)}throw"called children on a leaf node";},rY=function(a,b,c){a=TOa.g($APP.Vd(a));return a.h?a.h(b,c):a.call(null,b,c)},wY=function(a){if($APP.l(pY(a))){var b=
$APP.A.j(a,0,null),c=$APP.A.j(a,1,null),d=qY(a),e=$APP.u(d),f=$APP.v(e);e=$APP.y(e);return $APP.l(d)?$APP.Ud(new $APP.H(null,2,5,$APP.I,[f,new $APP.k(null,4,[sY,$APP.pg,tY,$APP.l(c)?$APP.Ve.h(tY.g(c),b):new $APP.H(null,1,5,$APP.I,[b],null),uY,c,vY,e],null)],null),$APP.Vd(a)):null}return null},yY=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null),d=$APP.xf(c);c=$APP.C.h(d,sY);var e=$APP.C.h(d,uY),f=$APP.C.h(d,tY),h=$APP.C.h(d,vY);d=$APP.C.h(d,xY);return $APP.l(f)?(f=$APP.Wd(f),$APP.Ud($APP.l(d)?
new $APP.H(null,2,5,$APP.I,[rY(a,f,$APP.K.h(c,$APP.Ye(b,h))),$APP.l(e)?$APP.Zh.j(e,xY,!0):e],null):new $APP.H(null,2,5,$APP.I,[f,e],null),$APP.Vd(a))):null},zY=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.xf(c);var d=$APP.C.h(c,sY),e=$APP.C.h(c,vY),f=$APP.u(e),h=$APP.v(f);f=$APP.y(f);return $APP.l($APP.l(c)?e:c)?$APP.Ud(new $APP.H(null,2,5,$APP.I,[h,$APP.Zh.l(c,sY,$APP.Ve.h(d,b),$APP.B([vY,f]))],null),$APP.Vd(a)):null},AY=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);
c=$APP.xf(c);var d=$APP.C.h(c,sY),e=$APP.C.h(c,vY);return $APP.l($APP.l(c)?e:c)?$APP.Ud(new $APP.H(null,2,5,$APP.I,[$APP.Pd(e),$APP.Zh.l(c,sY,$APP.Vf.G($APP.Ve,d,b,$APP.gi(e)),$APP.B([vY,null]))],null),$APP.Vd(a)):a},UOa=function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.xf(c);var d=$APP.C.h(c,sY),e=$APP.C.h(c,vY);return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.Ud(new $APP.H(null,2,5,$APP.I,[$APP.Wd(d),$APP.Zh.l(c,sY,$APP.Yd(d),$APP.B([vY,$APP.Ye(b,e)]))],null),$APP.Vd(a)):null},BY=function(a,
b){$APP.A.j(a,0,null);var c=$APP.A.j(a,1,null);return $APP.Ud(new $APP.H(null,2,5,$APP.I,[b,$APP.Zh.j(c,xY,!0)],null),$APP.Vd(a))},CY=new $APP.t(null,"make-node","make-node",-1550461835,null),VOa=new $APP.t("clojure.zip","append-child","clojure.zip/append-child",-1333956306,null),WOa=new $APP.t(null,"insert-right","insert-right",1842751767,null),XOa=new $APP.t("clojure.zip","insert-child","clojure.zip/insert-child",-210602132,null),YOa=new $APP.t("clojure.zip","end?","clojure.zip/end?",381053413,
null),ZOa=new $APP.t(null,"insert-left","insert-left",1917369949,null),$Oa=new $APP.t(null,"lefts","lefts",1054400638,null),aPa=new $APP.t("clojure.zip","node","clojure.zip/node",-1345203614,null),bPa=new $APP.t("clojure.zip","edit","clojure.zip/edit",-442418038,null),cPa=new $APP.t("clojure.zip","zipper","clojure.zip/zipper",-571036006,null),DY=new $APP.t(null,"item","item",1889905329,null),dPa=new $APP.t("clojure.zip","next","clojure.zip/next",-1526224397,null),SOa=new $APP.F("zip","children","zip/children",
-940194589),ePa=new $APP.t(null,"up","up",1370819414,null),fPa=new $APP.t("clojure.zip","branch?","clojure.zip/branch?",-1006947869,null),gPa=new $APP.t("clojure.zip","up","clojure.zip/up",1006365229,null),hPa=new $APP.t("clojure.zip","children","clojure.zip/children",65376544,null),iPa=new $APP.t("clojure.zip","leftmost","clojure.zip/leftmost",-1791272498,null),jPa=new $APP.t(null,"leftmost","leftmost",-1158121305,null),tY=new $APP.F(null,"pnodes","pnodes",1739080565),kPa=new $APP.t(null,"xml-zip",
"xml-zip",-1566989793,null),lPa=new $APP.t("clojure.zip","replace","clojure.zip/replace",413367034,null),mPa=new $APP.t(null,"end?","end?",217139918,null),nPa=new $APP.t("clojure.zip","path","clojure.zip/path",1758958974,null),oPa=new $APP.t("clojure.zip","rightmost","clojure.zip/rightmost",1799140158,null),pPa=new $APP.t("clojure.zip","xml-zip","clojure.zip/xml-zip",-925187274,null),qPa=new $APP.t("clojure.zip","down","clojure.zip/down",1356031458,null),rPa=new $APP.F(null,"content","content",15833224),
TOa=new $APP.F("zip","make-node","zip/make-node",1103800591),sPa=new $APP.t("clojure.zip","seq-zip","clojure.zip/seq-zip",-395973642,null),tPa=new $APP.t("clojure.zip","prev","clojure.zip/prev",-389017676,null),uPa=new $APP.t("clojure.zip","insert-right","clojure.zip/insert-right",194316302,null),vPa=new $APP.t("clojure.zip","vector-zip","clojure.zip/vector-zip",986730862,null),xY=new $APP.F(null,"changed?","changed?",-437828330),wPa=new $APP.t(null,"zipper","zipper",-1153741331,null),xPa=new $APP.t("clojure.zip",
"left","clojure.zip/left",1740332703,null),yPa=new $APP.t(null,"append-child","append-child",-1707191801,null),zPa=new $APP.t("clojure.zip","root","clojure.zip/root",-1119588559,null),APa=new $APP.t(null,"vector-zip","vector-zip",1075131029,null),BPa=new $APP.t(null,"insert-child","insert-child",347166277,null),CPa=new $APP.t("clojure.zip","remove","clojure.zip/remove",859584278,null),DPa=new $APP.t("clojure.zip","insert-left","clojure.zip/insert-left",1476893044,null),EPa=new $APP.t(null,"rightmost",
"rightmost",-1854156251,null),FPa=new $APP.t("clojure.zip","rights","clojure.zip/rights",1361118051,null),GPa=new $APP.t("clojure.zip","make-node","clojure.zip/make-node",-640223892,null),HPa=new $APP.t(null,"seq-zip","seq-zip",-2034709283,null),IPa=new $APP.t(null,"down","down",-1089190199,null),JPa=new $APP.t(null,"rights","rights",2003591322,null),vY=new $APP.F(null,"r","r",-471384190),sY=new $APP.F(null,"l","l",1395893423),KPa=new $APP.t("clojure.zip","right","clojure.zip/right",-1593586409,null),
uY=new $APP.F(null,"ppath","ppath",-1758182784),EY=new $APP.t(null,"loc","loc",1056246626,null),ROa=new $APP.F("zip","branch?","zip/branch?",-998880862),LPa=new $APP.t("clojure.zip","lefts","clojure.zip/lefts",538689815,null);var FY=function FY(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return FY.l(arguments[0],arguments[1],2<c.length?new $APP.jd(c.slice(2),0,null):null)};FY.l=function(a,b,c){return BY(a,$APP.Vf.j(b,oY(a),c))};FY.A=2;FY.F=function(a){var b=$APP.v(a),c=$APP.y(a);a=$APP.v(c);c=$APP.y(c);return this.l(b,a,c)};var MPa=$APP.DO.h($APP.hK,null),NPa=$APP.mt($APP.Hh([$APP.Ud(wPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,4,5,$APP.I,[$APP.RF,$APP.kE,CY,$APP.RI],null))),$APP.N,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],
null)),$APP.Ud(ePa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)),$APP.Ud($APP.Tva,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)),$APP.Ud(WOa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,2,5,
$APP.I,[EY,DY],null))),$APP.N,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)),$APP.Ud(ZOa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,DY],null))),$APP.N,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)),$APP.Ud(mPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns true if loc represents the end of a depth-first walk"],null)),$APP.Ud($APP.dB,
new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns the node at loc"],null)),$APP.Ud($APP.nL,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,$APP.dB],null))),$APP.N,"Replaces the node at this loc, without moving"],null)),$APP.Ud($APP.Eoa,new $APP.k(null,3,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,4,5,$APP.I,[EY,$APP.jH,$APP.Kj,$APP.jA],null))),$APP.N,"Replaces the node at this loc with the value of (f node args)",
$APP.iI,new $APP.k(null,6,[$APP.sx,!0,$APP.Tr,2,$APP.BK,2,$APP.TJ,new $APP.H(null,1,5,$APP.I,[$APP.J(EY,$APP.jH,$APP.jA)],null),$APP.Z,$APP.J(new $APP.H(null,4,5,$APP.I,[EY,$APP.jH,$APP.Kj,$APP.jA],null)),$APP.xC,$APP.J(null)],null)],null)),$APP.Ud(HPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.RI],null))),$APP.N,"Returns a zipper for nested sequences, given a root sequence"],null)),$APP.Ud($APP.sI,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,
1,5,$APP.I,[EY],null))),$APP.N,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],null)),$APP.Ud(kPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.RI],null))),$APP.N,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)),$APP.Ud(APa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.RI],
null))),$APP.N,"Returns a zipper for nested vectors, given a root vector"],null)),$APP.Ud(CY,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,3,5,$APP.I,[EY,$APP.dB,$APP.kE],null))),$APP.N,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)),$APP.Ud($APP.RF,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns true if the node at loc is a branch"],null)),$APP.Ud($APP.Xma,
new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns the loc of the right sibling of the node at this loc, or nil"],null)),$APP.Ud($APP.dva,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns a seq of nodes leading to this loc"],null)),$APP.Ud($APP.RI,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"zips all the way up and returns the root node, reflecting any\n changes."],
null)),$APP.Ud(JPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns a seq of the right siblings of this loc"],null)),$APP.Ud($APP.kE,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns a seq of the children of node at loc, which must be a branch"],null)),$APP.Ud(jPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns the loc of the leftmost sibling of the node at this loc, or self"],
null)),$APP.Ud(IPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)),$APP.Ud($APP.zta,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns the loc of the left sibling of the node at this loc, or nil"],null)),$APP.Ud($Oa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),
$APP.N,"Returns a seq of the left siblings of this loc"],null)),$APP.Ud(BPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,DY],null))),$APP.N,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)),$APP.Ud(yPa,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,DY],null))),$APP.N,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)),$APP.Ud(EPa,new $APP.k(null,2,[$APP.Z,
$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)),$APP.Ud($APP.rx,new $APP.k(null,2,[$APP.Z,$APP.J($APP.Zj,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null))),$APP.N,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],null))],[new $APP.k(null,3,[$APP.O,cPa,$APP.lt,nY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,4,5,$APP.I,[$APP.RF,$APP.kE,CY,
$APP.RI],null)),$APP.N,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],null)],null),new $APP.k(null,3,[$APP.O,gPa,$APP.lt,yY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,
1,5,$APP.I,[EY],null)),$APP.N,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)],null),new $APP.k(null,3,[$APP.O,tPa,$APP.lt,function(a){var b=UOa(a);if($APP.l(b))for(a=b;;)if(b=pY(a),b=$APP.l(b)?wY(a):b,$APP.l(b))a=AY(b);else return a;else return yY(a)},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],null)],null),new $APP.k(null,
3,[$APP.O,uPa,$APP.lt,function(a,b){var c=$APP.A.j(a,0,null),d=$APP.A.j(a,1,null);d=$APP.xf(d);var e=$APP.C.h(d,vY);if(null==d)throw"Insert at top";return $APP.Ud(new $APP.H(null,2,5,$APP.I,[c,$APP.Zh.l(d,vY,$APP.Ye(b,e),$APP.B([xY,!0]))],null),$APP.Vd(a))},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,DY],null)),$APP.N,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.O,DPa,$APP.lt,function(a,b){var c=
$APP.A.j(a,0,null),d=$APP.A.j(a,1,null);d=$APP.xf(d);var e=$APP.C.h(d,sY);if(null==d)throw"Insert at top";return $APP.Ud(new $APP.H(null,2,5,$APP.I,[c,$APP.Zh.l(d,sY,$APP.Ve.h(e,b),$APP.B([xY,!0]))],null),$APP.Vd(a))},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,DY],null)),$APP.N,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)],null),new $APP.k(null,3,[$APP.O,YOa,$APP.lt,function(a){return $APP.z.h($APP.DE,a.g?a.g(1):a.call(null,1))},
$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns true if loc represents the end of a depth-first walk"],null)],null),new $APP.k(null,3,[$APP.O,aPa,$APP.lt,oY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns the node at loc"],null)],null),new $APP.k(null,3,[$APP.O,lPa,$APP.lt,BY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,$APP.dB],null)),$APP.N,"Replaces the node at this loc, without moving"],
null)],null),new $APP.k(null,3,[$APP.O,bPa,$APP.lt,FY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,4,5,$APP.I,[EY,$APP.jH,$APP.Kj,$APP.jA],null)),$APP.N,"Replaces the node at this loc with the value of (f node args)"],null)],null),new $APP.k(null,3,[$APP.O,sPa,$APP.lt,function(a){return nY($APP.le,$APP.Ee,function(b,c){return $APP.Ud(c,$APP.Vd(b))},a)},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.RI],null)),$APP.N,"Returns a zipper for nested sequences, given a root sequence"],
null)],null),new $APP.k(null,3,[$APP.O,dPa,$APP.lt,function(a){if($APP.z.h($APP.DE,a.g?a.g(1):a.call(null,1)))return a;var b=pY(a);b=$APP.l(b)?wY(a):b;if($APP.l(b))return b;b=zY(a);if($APP.l(b))return b;for(;;)if($APP.l(yY(a))){b=zY(yY(a));if($APP.l(b))return b;a=yY(a)}else return new $APP.H(null,2,5,$APP.I,[oY(a),$APP.DE],null)},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],
null)],null),new $APP.k(null,3,[$APP.O,pPa,$APP.lt,function(a){return nY($APP.Wf($APP.qaa),$APP.rp.h($APP.u,rPa),function(b,c){return $APP.Zh.j(b,rPa,$APP.l(c)?$APP.Vf.h($APP.qv,c):c)},a)},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.RI],null)),$APP.N,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)],null),new $APP.k(null,3,[$APP.O,vPa,$APP.lt,function(a){return nY($APP.ge,$APP.u,function(b,c){return $APP.Ud($APP.Ce(c),$APP.Vd(b))},
a)},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[$APP.RI],null)),$APP.N,"Returns a zipper for nested vectors, given a root vector"],null)],null),new $APP.k(null,3,[$APP.O,GPa,$APP.lt,rY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,3,5,$APP.I,[EY,$APP.dB,$APP.kE],null)),$APP.N,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)],null),new $APP.k(null,3,[$APP.O,fPa,$APP.lt,pY,$APP.Ta,new $APP.k(null,
2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns true if the node at loc is a branch"],null)],null),new $APP.k(null,3,[$APP.O,KPa,$APP.lt,zY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns the loc of the right sibling of the node at this loc, or nil"],null)],null),new $APP.k(null,3,[$APP.O,nPa,$APP.lt,function(a){return tY.g(a.g?a.g(1):a.call(null,1))},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),
$APP.N,"Returns a seq of nodes leading to this loc"],null)],null),new $APP.k(null,3,[$APP.O,zPa,$APP.lt,function(a){for(;;){if($APP.z.h($APP.DE,a.g?a.g(1):a.call(null,1)))return oY(a);var b=yY(a);if($APP.l(b))a=b;else return oY(a)}},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"zips all the way up and returns the root node, reflecting any\n changes."],null)],null),new $APP.k(null,3,[$APP.O,FPa,$APP.lt,function(a){return vY.g(a.g?a.g(1):a.call(null,1))},$APP.Ta,
new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns a seq of the right siblings of this loc"],null)],null),new $APP.k(null,3,[$APP.O,hPa,$APP.lt,qY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns a seq of the children of node at loc, which must be a branch"],null)],null),new $APP.k(null,3,[$APP.O,iPa,$APP.lt,function(a){var b=$APP.A.j(a,0,null),c=$APP.A.j(a,1,null);c=$APP.xf(c);var d=$APP.C.h(c,sY),e=$APP.C.h(c,vY);
return $APP.l($APP.l(c)?$APP.u(d):c)?$APP.Ud(new $APP.H(null,2,5,$APP.I,[$APP.v(d),$APP.Zh.l(c,sY,$APP.pg,$APP.B([vY,$APP.K.l($APP.nd(d),new $APP.H(null,1,5,$APP.I,[b],null),$APP.B([e]))]))],null),$APP.Vd(a)):a},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns the loc of the leftmost sibling of the node at this loc, or self"],null)],null),new $APP.k(null,3,[$APP.O,qPa,$APP.lt,wY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],
null)),$APP.N,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)],null),new $APP.k(null,3,[$APP.O,xPa,$APP.lt,UOa,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns the loc of the left sibling of the node at this loc, or nil"],null)],null),new $APP.k(null,3,[$APP.O,LPa,$APP.lt,function(a){return $APP.u(sY.g(a.g?a.g(1):a.call(null,1)))},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],
null)),$APP.N,"Returns a seq of the left siblings of this loc"],null)],null),new $APP.k(null,3,[$APP.O,XOa,$APP.lt,function(a,b){return BY(a,rY(a,oY(a),$APP.Ye(b,qY(a))))},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,DY],null)),$APP.N,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.O,VOa,$APP.lt,function(a,b){return BY(a,rY(a,oY(a),$APP.K.h(qY(a),new $APP.H(null,1,5,$APP.I,[b],null))))},$APP.Ta,new $APP.k(null,
2,[$APP.Z,$APP.J(new $APP.H(null,2,5,$APP.I,[EY,DY],null)),$APP.N,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)],null),new $APP.k(null,3,[$APP.O,oPa,$APP.lt,AY,$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)],null),new $APP.k(null,3,[$APP.O,CPa,$APP.lt,function(a){$APP.A.j(a,0,null);var b=$APP.A.j(a,1,null);b=$APP.xf(b);var c=$APP.C.h(b,
sY),d=$APP.C.h(b,uY),e=$APP.C.h(b,tY),f=$APP.C.h(b,vY);if(null==b)throw"Remove at top";if(0<$APP.Fd(c))for(a=$APP.Ud(new $APP.H(null,2,5,$APP.I,[$APP.Wd(c),$APP.Zh.l(b,sY,$APP.Yd(c),$APP.B([xY,!0]))],null),$APP.Vd(a));;)if(b=pY(a),b=$APP.l(b)?wY(a):b,$APP.l(b))a=AY(b);else return a;else return $APP.Ud(new $APP.H(null,2,5,$APP.I,[rY(a,$APP.Wd(e),f),$APP.l(d)?$APP.Zh.j(d,xY,!0):d],null),$APP.Vd(a))},$APP.Ta,new $APP.k(null,2,[$APP.Z,$APP.J(new $APP.H(null,1,5,$APP.I,[EY],null)),$APP.N,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],
null)],null)]),MPa);$APP.Zt(new $APP.k(null,1,[$APP.Kp,new $APP.k(null,1,[$APP.hK,NPa],null)],null));