import { $APP, shadow$provide, $jscomp } from "./nbb_core.js";
const shadow_esm_import = function(x) { return import(x) };
var e0=function(a,b,c,d){return $APP.Ae(new $APP.H(null,2,5,$APP.I,[d,null],null),new $APP.g(null,3,[nTa,a,oTa,b,pTa,c],null))},i0=function(a){return a.g?a.g(0):a.call(null,0)},p0=function(a){var b=i0(a);a=nTa.g($APP.Be(a));return a.g?a.g(b):a.call(null,b)},J0=function(a){if($APP.m(p0(a))){var b=i0(a);a=oTa.g($APP.Be(a));return a.g?a.g(b):a.call(null,b)}throw"called children on a leaf node";},Z0=function(a,b,c){a=pTa.g($APP.Be(a));return a.h?a.h(b,c):a.call(null,b,c)},l1=function(a){if($APP.m(p0(a))){var b=
$APP.C.j(a,0,null),c=$APP.C.j(a,1,null),d=J0(a),e=$APP.u(d),h=$APP.x(e);e=$APP.z(e);return $APP.m(d)?$APP.Ae(new $APP.H(null,2,5,$APP.I,[h,new $APP.g(null,4,[LV,$APP.qi,NV,$APP.m(c)?$APP.Cg.h(NV.g(c),b):new $APP.H(null,1,5,$APP.I,[b],null),qTa,c,OV,e],null)],null),$APP.Be(a)):null}return null},o1=function(a){var b=$APP.C.j(a,0,null),c=$APP.C.j(a,1,null),d=$APP.ph(c);c=$APP.gf.h(d,LV);var e=$APP.gf.h(d,qTa),h=$APP.gf.h(d,NV),l=$APP.gf.h(d,OV);d=$APP.gf.h(d,PV);return $APP.m(h)?(h=$APP.Ce(h),$APP.Ae($APP.m(d)?
new $APP.H(null,2,5,$APP.I,[Z0(a,h,$APP.S.h(c,$APP.Fg(b,l))),$APP.m(e)?$APP.K.j(e,PV,!0):e],null):new $APP.H(null,2,5,$APP.I,[h,e],null),$APP.Be(a))):null},LKa=function(a){var b=$APP.C.j(a,0,null),c=$APP.C.j(a,1,null);c=$APP.ph(c);var d=$APP.gf.h(c,LV),e=$APP.gf.h(c,OV),h=$APP.u(e),l=$APP.x(h);h=$APP.z(h);return $APP.m($APP.m(c)?e:c)?$APP.Ae(new $APP.H(null,2,5,$APP.I,[l,$APP.K.l(c,LV,$APP.Cg.h(d,b),$APP.F([OV,h]))],null),$APP.Be(a)):null},MKa=function(a){var b=$APP.C.j(a,0,null),c=$APP.C.j(a,1,null);
c=$APP.ph(c);var d=$APP.gf.h(c,LV),e=$APP.gf.h(c,OV);return $APP.m($APP.m(c)?e:c)?$APP.Ae(new $APP.H(null,2,5,$APP.I,[$APP.te(e),$APP.K.l(c,LV,$APP.nh.I($APP.Cg,d,b,$APP.rk(e)),$APP.F([OV,null]))],null),$APP.Be(a)):a},NKa=function(a){var b=$APP.C.j(a,0,null),c=$APP.C.j(a,1,null);c=$APP.ph(c);var d=$APP.gf.h(c,LV),e=$APP.gf.h(c,OV);return $APP.m($APP.m(c)?$APP.u(d):c)?$APP.Ae(new $APP.H(null,2,5,$APP.I,[$APP.Ce(d),$APP.K.l(c,LV,$APP.De(d),$APP.F([OV,$APP.Fg(b,e)]))],null),$APP.Be(a)):null},p1=function(a,
b){$APP.C.j(a,0,null);var c=$APP.C.j(a,1,null);return $APP.Ae(new $APP.H(null,2,5,$APP.I,[b,$APP.K.j(c,PV,!0)],null),$APP.Be(a))},rTa=new $APP.r(null,"make-node","make-node",-1550461835,null),sTa=new $APP.r("clojure.zip","append-child","clojure.zip/append-child",-1333956306,null),tTa=new $APP.r(null,"insert-right","insert-right",1842751767,null),uTa=new $APP.r("clojure.zip","insert-child","clojure.zip/insert-child",-210602132,null),vTa=new $APP.r("clojure.zip","end?","clojure.zip/end?",381053413,
null),wTa=new $APP.r(null,"insert-left","insert-left",1917369949,null),xTa=new $APP.r(null,"lefts","lefts",1054400638,null),yTa=new $APP.r("clojure.zip","node","clojure.zip/node",-1345203614,null),zTa=new $APP.r("clojure.zip","edit","clojure.zip/edit",-442418038,null),DTa=new $APP.r("clojure.zip","zipper","clojure.zip/zipper",-571036006,null),RV=new $APP.r(null,"item","item",1889905329,null),ETa=new $APP.r("clojure.zip","next","clojure.zip/next",-1526224397,null),oTa=new $APP.k("zip","children","zip/children",
-940194589),HTa=new $APP.r(null,"up","up",1370819414,null),ITa=new $APP.r("clojure.zip","branch?","clojure.zip/branch?",-1006947869,null),JTa=new $APP.r("clojure.zip","up","clojure.zip/up",1006365229,null),KTa=new $APP.r("clojure.zip","children","clojure.zip/children",65376544,null),LTa=new $APP.r("clojure.zip","leftmost","clojure.zip/leftmost",-1791272498,null),MTa=new $APP.r(null,"leftmost","leftmost",-1158121305,null),NV=new $APP.k(null,"pnodes","pnodes",1739080565),NTa=new $APP.r(null,"xml-zip",
"xml-zip",-1566989793,null),PTa=new $APP.r("clojure.zip","replace","clojure.zip/replace",413367034,null),QTa=new $APP.r(null,"end?","end?",217139918,null),RTa=new $APP.r("clojure.zip","path","clojure.zip/path",1758958974,null),STa=new $APP.r("clojure.zip","rightmost","clojure.zip/rightmost",1799140158,null),TTa=new $APP.r("clojure.zip","xml-zip","clojure.zip/xml-zip",-925187274,null),UTa=new $APP.r("clojure.zip","down","clojure.zip/down",1356031458,null),VTa=new $APP.k(null,"content","content",15833224),
pTa=new $APP.k("zip","make-node","zip/make-node",1103800591),WTa=new $APP.r("clojure.zip","seq-zip","clojure.zip/seq-zip",-395973642,null),YTa=new $APP.r("clojure.zip","prev","clojure.zip/prev",-389017676,null),$Ta=new $APP.r("clojure.zip","insert-right","clojure.zip/insert-right",194316302,null),aUa=new $APP.r("clojure.zip","vector-zip","clojure.zip/vector-zip",986730862,null),PV=new $APP.k(null,"changed?","changed?",-437828330),bUa=new $APP.r(null,"zipper","zipper",-1153741331,null),cUa=new $APP.r("clojure.zip",
"left","clojure.zip/left",1740332703,null),dUa=new $APP.r(null,"append-child","append-child",-1707191801,null),eUa=new $APP.r("clojure.zip","root","clojure.zip/root",-1119588559,null),fUa=new $APP.r(null,"vector-zip","vector-zip",1075131029,null),gUa=new $APP.r(null,"insert-child","insert-child",347166277,null),jUa=new $APP.r("clojure.zip","remove","clojure.zip/remove",859584278,null),kUa=new $APP.r("clojure.zip","insert-left","clojure.zip/insert-left",1476893044,null),lUa=new $APP.r(null,"rightmost",
"rightmost",-1854156251,null),mUa=new $APP.r("clojure.zip","rights","clojure.zip/rights",1361118051,null),oUa=new $APP.r("clojure.zip","make-node","clojure.zip/make-node",-640223892,null),pUa=new $APP.r(null,"seq-zip","seq-zip",-2034709283,null),qUa=new $APP.r(null,"down","down",-1089190199,null),rUa=new $APP.r(null,"rights","rights",2003591322,null),OV=new $APP.k(null,"r","r",-471384190),LV=new $APP.k(null,"l","l",1395893423),tUa=new $APP.r("clojure.zip","right","clojure.zip/right",-1593586409,null),
qTa=new $APP.k(null,"ppath","ppath",-1758182784),SV=new $APP.r(null,"loc","loc",1056246626,null),nTa=new $APP.k("zip","branch?","zip/branch?",-998880862),uUa=new $APP.r("clojure.zip","lefts","clojure.zip/lefts",538689815,null);var D1=function D1(a){for(var c=[],d=arguments.length,e=0;;)if(e<d)c.push(arguments[e]),e+=1;else break;return D1.l(arguments[0],arguments[1],2<c.length?new $APP.Fd(c.slice(2),0,null):null)};D1.l=function(a,b,c){return p1(a,$APP.nh.j(b,i0(a),c))};D1.C=2;D1.G=function(a){var b=$APP.x(a),c=$APP.z(a);a=$APP.x(c);c=$APP.z(c);return this.l(b,a,c)};var dMa=$APP.zJ.h($APP.EDa,null),eMa=$APP.gta($APP.Oj([bUa,HTa,$APP.Iza,tTa,wTa,QTa,$APP.bG,$APP.OI,$APP.Ila,pUa,$APP.DJ,NTa,fUa,rTa,$APP.Lxa,$APP.pia,$APP.kEa,$APP.LJ,rUa,$APP.EF,MTa,qUa,$APP.Fwa,xTa,gUa,dUa,lUa,$APP.rC],[new $APP.g(null,3,[$APP.U,DTa,$APP.xx,e0,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,4,5,$APP.I,[$APP.Lxa,$APP.EF,rTa,$APP.LJ],null)),$APP.N,"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],
null)],null),new $APP.g(null,3,[$APP.U,JTa,$APP.xx,o1,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],null)],null),new $APP.g(null,3,[$APP.U,YTa,$APP.xx,function(a){var b=NKa(a);if($APP.m(b))for(a=b;;)if(b=p0(a),b=$APP.m(b)?l1(a):b,$APP.m(b))a=MKa(b);else return a;else return o1(a)},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],
null)],null),new $APP.g(null,3,[$APP.U,$Ta,$APP.xx,function(a,b){var c=$APP.C.j(a,0,null),d=$APP.C.j(a,1,null);d=$APP.ph(d);var e=$APP.gf.h(d,OV);if(null==d)throw"Insert at top";return $APP.Ae(new $APP.H(null,2,5,$APP.I,[c,$APP.K.l(d,OV,$APP.Fg(b,e),$APP.F([PV,!0]))],null),$APP.Be(a))},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,2,5,$APP.I,[SV,RV],null)),$APP.N,"Inserts the item as the right sibling of the node at this loc,\n  without moving"],null)],null),new $APP.g(null,3,[$APP.U,kUa,
$APP.xx,function(a,b){var c=$APP.C.j(a,0,null),d=$APP.C.j(a,1,null);d=$APP.ph(d);var e=$APP.gf.h(d,LV);if(null==d)throw"Insert at top";return $APP.Ae(new $APP.H(null,2,5,$APP.I,[c,$APP.K.l(d,LV,$APP.Cg.h(e,b),$APP.F([PV,!0]))],null),$APP.Be(a))},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,2,5,$APP.I,[SV,RV],null)),$APP.N,"Inserts the item as the left sibling of the node at this loc,\n without moving"],null)],null),new $APP.g(null,3,[$APP.U,vTa,$APP.xx,function(a){return $APP.B.h($APP.OF,
a.g?a.g(1):a.call(null,1))},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns true if loc represents the end of a depth-first walk"],null)],null),new $APP.g(null,3,[$APP.U,yTa,$APP.xx,i0,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns the node at loc"],null)],null),new $APP.g(null,3,[$APP.U,PTa,$APP.xx,p1,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,2,5,$APP.I,[SV,$APP.bG],null)),$APP.N,"Replaces the node at this loc, without moving"],
null)],null),new $APP.g(null,3,[$APP.U,zTa,$APP.xx,D1,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,4,5,$APP.I,[SV,$APP.RI,$APP.ah,$APP.aE],null)),$APP.N,"Replaces the node at this loc with the value of (f node args)"],null)],null),new $APP.g(null,3,[$APP.U,WTa,$APP.xx,function(a){return e0($APP.We,$APP.zf,function(b,c){return $APP.Ae(c,$APP.Be(b))},a)},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[$APP.LJ],null)),$APP.N,"Returns a zipper for nested sequences, given a root sequence"],
null)],null),new $APP.g(null,3,[$APP.U,ETa,$APP.xx,function(a){if($APP.B.h($APP.OF,a.g?a.g(1):a.call(null,1)))return a;var b=p0(a);b=$APP.m(b)?l1(a):b;if($APP.m(b))return b;b=LKa(a);if($APP.m(b))return b;for(;;)if($APP.m(o1(a))){b=LKa(o1(a));if($APP.m(b))return b;a=o1(a)}else return new $APP.H(null,2,5,$APP.I,[i0(a),$APP.OF],null)},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],
null)],null),new $APP.g(null,3,[$APP.U,TTa,$APP.xx,function(a){return e0($APP.Qh($APP.daa),$APP.Pt.h($APP.u,VTa),function(b,c){return $APP.K.j(b,VTa,$APP.m(c)?$APP.nh.h($APP.Tt,c):c)},a)},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[$APP.LJ],null)),$APP.N,"Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],null)],null),new $APP.g(null,3,[$APP.U,aUa,$APP.xx,function(a){return e0($APP.Ne,$APP.u,function(b,c){return $APP.Ae($APP.uf(c),$APP.Be(b))},
a)},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[$APP.LJ],null)),$APP.N,"Returns a zipper for nested vectors, given a root vector"],null)],null),new $APP.g(null,3,[$APP.U,oUa,$APP.xx,Z0,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,3,5,$APP.I,[SV,$APP.bG,$APP.EF],null)),$APP.N,"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],null)],null),new $APP.g(null,3,[$APP.U,ITa,$APP.xx,p0,$APP.Xa,new $APP.g(null,
2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns true if the node at loc is a branch"],null)],null),new $APP.g(null,3,[$APP.U,tUa,$APP.xx,LKa,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns the loc of the right sibling of the node at this loc, or nil"],null)],null),new $APP.g(null,3,[$APP.U,RTa,$APP.xx,function(a){return NV.g(a.g?a.g(1):a.call(null,1))},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),
$APP.N,"Returns a seq of nodes leading to this loc"],null)],null),new $APP.g(null,3,[$APP.U,eUa,$APP.xx,function(a){for(;;){if($APP.B.h($APP.OF,a.g?a.g(1):a.call(null,1)))return i0(a);var b=o1(a);if($APP.m(b))a=b;else return i0(a)}},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"zips all the way up and returns the root node, reflecting any\n changes."],null)],null),new $APP.g(null,3,[$APP.U,mUa,$APP.xx,function(a){return OV.g(a.g?a.g(1):a.call(null,1))},$APP.Xa,
new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns a seq of the right siblings of this loc"],null)],null),new $APP.g(null,3,[$APP.U,KTa,$APP.xx,J0,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns a seq of the children of node at loc, which must be a branch"],null)],null),new $APP.g(null,3,[$APP.U,LTa,$APP.xx,function(a){var b=$APP.C.j(a,0,null),c=$APP.C.j(a,1,null);c=$APP.ph(c);var d=$APP.gf.h(c,LV),e=$APP.gf.h(c,
OV);return $APP.m($APP.m(c)?$APP.u(d):c)?$APP.Ae(new $APP.H(null,2,5,$APP.I,[$APP.x(d),$APP.K.l(c,LV,$APP.qi,$APP.F([OV,$APP.S.l($APP.Jd(d),new $APP.H(null,1,5,$APP.I,[b],null),$APP.F([e]))]))],null),$APP.Be(a)):a},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns the loc of the leftmost sibling of the node at this loc, or self"],null)],null),new $APP.g(null,3,[$APP.U,UTa,$APP.xx,l1,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],
null)),$APP.N,"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],null)],null),new $APP.g(null,3,[$APP.U,cUa,$APP.xx,NKa,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns the loc of the left sibling of the node at this loc, or nil"],null)],null),new $APP.g(null,3,[$APP.U,uUa,$APP.xx,function(a){return $APP.u(LV.g(a.g?a.g(1):a.call(null,1)))},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],
null)),$APP.N,"Returns a seq of the left siblings of this loc"],null)],null),new $APP.g(null,3,[$APP.U,uTa,$APP.xx,function(a,b){return p1(a,Z0(a,i0(a),$APP.Fg(b,J0(a))))},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,2,5,$APP.I,[SV,RV],null)),$APP.N,"Inserts the item as the leftmost child of the node at this loc,\n  without moving"],null)],null),new $APP.g(null,3,[$APP.U,sTa,$APP.xx,function(a,b){return p1(a,Z0(a,i0(a),$APP.S.h(J0(a),new $APP.H(null,1,5,$APP.I,[b],null))))},$APP.Xa,new $APP.g(null,
2,[$APP.V,$APP.R(new $APP.H(null,2,5,$APP.I,[SV,RV],null)),$APP.N,"Inserts the item as the rightmost child of the node at this loc,\n  without moving"],null)],null),new $APP.g(null,3,[$APP.U,STa,$APP.xx,MKa,$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Returns the loc of the rightmost sibling of the node at this loc, or self"],null)],null),new $APP.g(null,3,[$APP.U,jUa,$APP.xx,function(a){$APP.C.j(a,0,null);var b=$APP.C.j(a,1,null);b=$APP.ph(b);var c=$APP.gf.h(b,
LV),d=$APP.gf.h(b,qTa),e=$APP.gf.h(b,NV),h=$APP.gf.h(b,OV);if(null==b)throw"Remove at top";if(0<$APP.ie(c))for(a=$APP.Ae(new $APP.H(null,2,5,$APP.I,[$APP.Ce(c),$APP.K.l(b,LV,$APP.De(c),$APP.F([PV,!0]))],null),$APP.Be(a));;)if(b=p0(a),b=$APP.m(b)?l1(a):b,$APP.m(b))a=MKa(b);else return a;else return $APP.Ae(new $APP.H(null,2,5,$APP.I,[Z0(a,$APP.Ce(e),h),$APP.m(d)?$APP.K.j(d,PV,!0):d],null),$APP.Be(a))},$APP.Xa,new $APP.g(null,2,[$APP.V,$APP.R(new $APP.H(null,1,5,$APP.I,[SV],null)),$APP.N,"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],
null)],null)]),dMa);$APP.Wy(new $APP.g(null,1,[$APP.Ft,new $APP.g(null,1,[$APP.EDa,eMa],null)],null));